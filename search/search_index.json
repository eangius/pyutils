{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"","title":"About"},{"location":"api_multimap.html","text":"MultiMap Mutable collection type that bi-directionally stores mappings of source & destination items. This type is similar to regular dictionaries except that it supports having many-to-many relationships in the collection. This type is also similar to regular tuple lists with added support for fast indexed lookup of items by source or destination keys. All source & destinations must be hashable. Item storage in internally handled by this class to save memory. Meaning any dangling source or destination nodes without relationships are removed from the map. While this type is memory based, the interface represents an abstraction between function vs memory mapping implementations. That is, callers need not know weather a mapping is derived as a computation or lookups. So all forward & backwards mappings of this type are possible via both [] indices & () calls. Source code in pyutils/multimap.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 class MultiMap : \"\"\" Mutable collection type that bi-directionally stores mappings of source & destination items. This type is similar to regular dictionaries except that it supports having many-to-many relationships in the collection. This type is also similar to regular tuple lists with added support for fast indexed lookup of items by source or destination keys. All source & destinations must be hashable. Item storage in internally handled by this class to save memory. Meaning any dangling source or destination nodes without relationships are removed from the map. While this type is memory based, the interface represents an abstraction between function vs memory mapping implementations. That is, callers need not know weather a mapping is derived as a computation or lookups. So all forward & backwards mappings of this type are possible via both ``[]`` indices & ``()`` calls. \"\"\" def __init__ ( self , items : Iterable [ Relation ] = None ): \"\"\" Constructor to instantiate an new ``MultiMap``. Args: items: Optional collection of source & destination nodes to map. \"\"\" self . _sources = dict () # outgoing frequencies self . _targets = dict () # incoming frequencies self . _items = None # state of iteration for src , dst in items or []: self . add ( src , dst ) return @cached_property def UNDEFINED ( self ): \"\"\" Readonly unique symbol denoting \"no-value\" of node so that ``None`` values can be handled in mapping. \"\"\" return object () @property def domain ( self ) -> Set [ Node ]: \"\"\" Retrieves the current set of distinct source nodes of this map. \"\"\" return set ( self . _sources . keys ()) @property def range ( self ) -> Set [ Node ]: \"\"\" Retrieves the current set of distinct target nodes of this map. \"\"\" return set ( self . _targets . keys ()) def items ( self ) -> Iterable [ Relation ]: \"\"\" Retrieves the current collection of source & destination relations in this map. \"\"\" return ( ( src , dst ) for src , ctr in self . _sources . items () for dst , freq in ctr . items () for _ in range ( freq ) ) def source ( self , src : Node ) -> List [ Node ]: \"\"\" Forward maps from a specific source node & returns its collection of related target nodes if any or empty otherwise. \"\"\" return [ dst for dst , freq in self . _sources . get ( src , dict ()) . items () for _ in range ( freq ) ] def target ( self , dst : Node ) -> List [ Node ]: \"\"\" Backwards maps from a specific target node & returns its collection of related source nodes if any or empty otherwise. \"\"\" return [ src for src , freq in self . _targets . get ( dst , dict ()) . items () for _ in range ( freq ) ] def size ( self ) -> int : \"\"\" Number of relationships in this map. \"\"\" return sum ( 1 for _ in self ) # unfolded out def inverse ( self , copy : bool = True ) -> 'MultiMap' : \"\"\" Reverses source & destination direction mapping of all relationships in this map. Args: copy: To perform operation in new map or in place. Returns: result: A mapping with source & destination nodes reversed. Same instance whenever ``copy=False`` \"\"\" if copy : return MultiMap ( ( dst , src ) for src , dst in self ) self . _sources , self . _targets = self . _targets , self . _sources return self def add ( self , src : Node , dst : Node ) -> 'MultiMap' : \"\"\" Inplace inserts a specific relationship to this map even if an identical one already exists. Args: src: Source node dst: Destination node Returns: result: Modified instance of this map. \"\"\" if src != MultiMap . UNDEFINED and dst != MultiMap . UNDEFINED : self . _sources . setdefault ( src , Counter ()) . update ([ dst ]) self . _targets . setdefault ( dst , Counter ()) . update ([ src ]) return self def remove ( self , src : Node , dst : Node ) -> 'MultiMap' : \"\"\" Inplace deletes specific relationships from this map. When multiple identical relationships exists, only 1 is removed. No effect if the relationship does not exists. Args: src: Source node. Removes all mappings from a destination when it is ``MultiMap.UNDEFINED`` dst: Destination node. Removes all mappings from a source when it is ``MultiMap.UNDEFINED`` Returns: result: Modified instance of this map. \"\"\" return self . __delitem__ (( src , dst )) def clear ( self ) -> 'MultiMap' : \"\"\" Inplace deletes all relationships in this map. Returns: result: Modified instance of this map. \"\"\" self . _sources . clear () self . _targets . clear () return self def copy ( self ) -> 'MultiMap' : \"\"\" Creates a new but shallow clone of this mapping. \"\"\" return MultiMap ( self ) # visually represent state of this map. def __repr__ ( self ) -> str : return str ( list ( self )) # number & frequency of relationships match another def __eq__ ( self , other : 'MultiMap' ) -> bool : return \\ isinstance ( other , self . __class__ ) and \\ self . _sources == other . _sources and \\ self . _targets == other . _targets # union as new mapping of this & another collection def __add__ ( self , other : 'MultiMap' ) -> 'MultiMap' : return reduce ( lambda result , item : result . add ( * item ), other , MultiMap ( self ) ) # difference as new mapping of this & other collection def __sub__ ( self , other : 'MultiMap' ) -> 'MultiMap' : return reduce ( lambda result , item : result . remove ( * item ), other , MultiMap ( self ) ) # identify if specific source to destination mapping exists. def __contains__ ( self , item : Relation ) -> bool : src , dst = item in_src = src in self . _sources in_dst = dst in self . _targets return \\ in_src if src != MultiMap . UNDEFINED and dst == MultiMap . UNDEFINED else \\ in_dst if src == MultiMap . UNDEFINED and dst != MultiMap . UNDEFINED else \\ in_src and in_dst # remove explicit relation or groups or relations. def __delitem__ ( self , item : Relation ) -> 'MultiMap' : src , dst = item if src != MultiMap . UNDEFINED and dst != MultiMap . UNDEFINED : self . _decrement_frequency ( self . _sources , src , dst ) self . _decrement_frequency ( self . _targets , dst , src ) return self if src != MultiMap . UNDEFINED : for dst in self . _sources [ src ] . keys (): self . _decrement_frequency ( self . _targets , dst , src ) del self . _sources [ src ] return self if dst != MultiMap . UNDEFINED : for src in self . _targets [ dst ] . keys (): self . _decrement_frequency ( self . _sources , src , dst ) del self . _targets [ dst ] return self return self . clear () __len__ = size # cardinality __iter__ = items # iterable like list __getitem__ = source # syntactic sugar idexable like list __call__ = source # syntactic sugar callable like function # ensure source/target keys are removed when no longer linked. # returns true if freq dictionary was modified. @staticmethod def _decrement_frequency ( freq : dict , k , v ) -> bool : if k not in freq : return False freq [ k ] -= Counter ([ v ]) if freq [ k ] == Counter (): del freq [ k ] return True UNDEFINED cached property Readonly unique symbol denoting \"no-value\" of node so that None values can be handled in mapping. domain : Set [ Node ] property Retrieves the current set of distinct source nodes of this map. range : Set [ Node ] property Retrieves the current set of distinct target nodes of this map. __init__ ( items = None ) Constructor to instantiate an new MultiMap . Parameters: items ( Iterable [ Relation ] , default: None ) \u2013 Optional collection of source & destination nodes to map. Source code in pyutils/multimap.py 33 34 35 36 37 38 39 40 41 42 43 44 45 def __init__ ( self , items : Iterable [ Relation ] = None ): \"\"\" Constructor to instantiate an new ``MultiMap``. Args: items: Optional collection of source & destination nodes to map. \"\"\" self . _sources = dict () # outgoing frequencies self . _targets = dict () # incoming frequencies self . _items = None # state of iteration for src , dst in items or []: self . add ( src , dst ) return add ( src , dst ) Inplace inserts a specific relationship to this map even if an identical one already exists. Parameters: src ( Node ) \u2013 Source node dst ( Node ) \u2013 Destination node Returns: result ( MultiMap ) \u2013 Modified instance of this map. Source code in pyutils/multimap.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def add ( self , src : Node , dst : Node ) -> 'MultiMap' : \"\"\" Inplace inserts a specific relationship to this map even if an identical one already exists. Args: src: Source node dst: Destination node Returns: result: Modified instance of this map. \"\"\" if src != MultiMap . UNDEFINED and dst != MultiMap . UNDEFINED : self . _sources . setdefault ( src , Counter ()) . update ([ dst ]) self . _targets . setdefault ( dst , Counter ()) . update ([ src ]) return self clear () Inplace deletes all relationships in this map. Returns: result ( MultiMap ) \u2013 Modified instance of this map. Source code in pyutils/multimap.py 160 161 162 163 164 165 166 167 168 169 def clear ( self ) -> 'MultiMap' : \"\"\" Inplace deletes all relationships in this map. Returns: result: Modified instance of this map. \"\"\" self . _sources . clear () self . _targets . clear () return self copy () Creates a new but shallow clone of this mapping. Source code in pyutils/multimap.py 171 172 173 174 175 def copy ( self ) -> 'MultiMap' : \"\"\" Creates a new but shallow clone of this mapping. \"\"\" return MultiMap ( self ) inverse ( copy = True ) Reverses source & destination direction mapping of all relationships in this map. Parameters: copy ( bool , default: True ) \u2013 To perform operation in new map or in place. Returns: result ( MultiMap ) \u2013 A mapping with source & destination nodes reversed. Same instance whenever copy=False Source code in pyutils/multimap.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def inverse ( self , copy : bool = True ) -> 'MultiMap' : \"\"\" Reverses source & destination direction mapping of all relationships in this map. Args: copy: To perform operation in new map or in place. Returns: result: A mapping with source & destination nodes reversed. Same instance whenever ``copy=False`` \"\"\" if copy : return MultiMap ( ( dst , src ) for src , dst in self ) self . _sources , self . _targets = self . _targets , self . _sources return self items () Retrieves the current collection of source & destination relations in this map. Source code in pyutils/multimap.py 69 70 71 72 73 74 75 76 77 78 def items ( self ) -> Iterable [ Relation ]: \"\"\" Retrieves the current collection of source & destination relations in this map. \"\"\" return ( ( src , dst ) for src , ctr in self . _sources . items () for dst , freq in ctr . items () for _ in range ( freq ) ) remove ( src , dst ) Inplace deletes specific relationships from this map. When multiple identical relationships exists, only 1 is removed. No effect if the relationship does not exists. Parameters: src ( Node ) \u2013 Source node. Removes all mappings from a destination when it is MultiMap.UNDEFINED dst ( Node ) \u2013 Destination node. Removes all mappings from a source when it is MultiMap.UNDEFINED Returns: result ( MultiMap ) \u2013 Modified instance of this map. Source code in pyutils/multimap.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def remove ( self , src : Node , dst : Node ) -> 'MultiMap' : \"\"\" Inplace deletes specific relationships from this map. When multiple identical relationships exists, only 1 is removed. No effect if the relationship does not exists. Args: src: Source node. Removes all mappings from a destination when it is ``MultiMap.UNDEFINED`` dst: Destination node. Removes all mappings from a source when it is ``MultiMap.UNDEFINED`` Returns: result: Modified instance of this map. \"\"\" return self . __delitem__ (( src , dst )) size () Number of relationships in this map. Source code in pyutils/multimap.py 102 103 104 105 106 def size ( self ) -> int : \"\"\" Number of relationships in this map. \"\"\" return sum ( 1 for _ in self ) # unfolded out source ( src ) Forward maps from a specific source node & returns its collection of related target nodes if any or empty otherwise. Source code in pyutils/multimap.py 80 81 82 83 84 85 86 87 88 89 def source ( self , src : Node ) -> List [ Node ]: \"\"\" Forward maps from a specific source node & returns its collection of related target nodes if any or empty otherwise. \"\"\" return [ dst for dst , freq in self . _sources . get ( src , dict ()) . items () for _ in range ( freq ) ] target ( dst ) Backwards maps from a specific target node & returns its collection of related source nodes if any or empty otherwise. Source code in pyutils/multimap.py 91 92 93 94 95 96 97 98 99 100 def target ( self , dst : Node ) -> List [ Node ]: \"\"\" Backwards maps from a specific target node & returns its collection of related source nodes if any or empty otherwise. \"\"\" return [ src for src , freq in self . _targets . get ( dst , dict ()) . items () for _ in range ( freq ) ]","title":"MultiMap"},{"location":"api_multimap.html#multimap","text":"Mutable collection type that bi-directionally stores mappings of source & destination items. This type is similar to regular dictionaries except that it supports having many-to-many relationships in the collection. This type is also similar to regular tuple lists with added support for fast indexed lookup of items by source or destination keys. All source & destinations must be hashable. Item storage in internally handled by this class to save memory. Meaning any dangling source or destination nodes without relationships are removed from the map. While this type is memory based, the interface represents an abstraction between function vs memory mapping implementations. That is, callers need not know weather a mapping is derived as a computation or lookups. So all forward & backwards mappings of this type are possible via both [] indices & () calls. Source code in pyutils/multimap.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 class MultiMap : \"\"\" Mutable collection type that bi-directionally stores mappings of source & destination items. This type is similar to regular dictionaries except that it supports having many-to-many relationships in the collection. This type is also similar to regular tuple lists with added support for fast indexed lookup of items by source or destination keys. All source & destinations must be hashable. Item storage in internally handled by this class to save memory. Meaning any dangling source or destination nodes without relationships are removed from the map. While this type is memory based, the interface represents an abstraction between function vs memory mapping implementations. That is, callers need not know weather a mapping is derived as a computation or lookups. So all forward & backwards mappings of this type are possible via both ``[]`` indices & ``()`` calls. \"\"\" def __init__ ( self , items : Iterable [ Relation ] = None ): \"\"\" Constructor to instantiate an new ``MultiMap``. Args: items: Optional collection of source & destination nodes to map. \"\"\" self . _sources = dict () # outgoing frequencies self . _targets = dict () # incoming frequencies self . _items = None # state of iteration for src , dst in items or []: self . add ( src , dst ) return @cached_property def UNDEFINED ( self ): \"\"\" Readonly unique symbol denoting \"no-value\" of node so that ``None`` values can be handled in mapping. \"\"\" return object () @property def domain ( self ) -> Set [ Node ]: \"\"\" Retrieves the current set of distinct source nodes of this map. \"\"\" return set ( self . _sources . keys ()) @property def range ( self ) -> Set [ Node ]: \"\"\" Retrieves the current set of distinct target nodes of this map. \"\"\" return set ( self . _targets . keys ()) def items ( self ) -> Iterable [ Relation ]: \"\"\" Retrieves the current collection of source & destination relations in this map. \"\"\" return ( ( src , dst ) for src , ctr in self . _sources . items () for dst , freq in ctr . items () for _ in range ( freq ) ) def source ( self , src : Node ) -> List [ Node ]: \"\"\" Forward maps from a specific source node & returns its collection of related target nodes if any or empty otherwise. \"\"\" return [ dst for dst , freq in self . _sources . get ( src , dict ()) . items () for _ in range ( freq ) ] def target ( self , dst : Node ) -> List [ Node ]: \"\"\" Backwards maps from a specific target node & returns its collection of related source nodes if any or empty otherwise. \"\"\" return [ src for src , freq in self . _targets . get ( dst , dict ()) . items () for _ in range ( freq ) ] def size ( self ) -> int : \"\"\" Number of relationships in this map. \"\"\" return sum ( 1 for _ in self ) # unfolded out def inverse ( self , copy : bool = True ) -> 'MultiMap' : \"\"\" Reverses source & destination direction mapping of all relationships in this map. Args: copy: To perform operation in new map or in place. Returns: result: A mapping with source & destination nodes reversed. Same instance whenever ``copy=False`` \"\"\" if copy : return MultiMap ( ( dst , src ) for src , dst in self ) self . _sources , self . _targets = self . _targets , self . _sources return self def add ( self , src : Node , dst : Node ) -> 'MultiMap' : \"\"\" Inplace inserts a specific relationship to this map even if an identical one already exists. Args: src: Source node dst: Destination node Returns: result: Modified instance of this map. \"\"\" if src != MultiMap . UNDEFINED and dst != MultiMap . UNDEFINED : self . _sources . setdefault ( src , Counter ()) . update ([ dst ]) self . _targets . setdefault ( dst , Counter ()) . update ([ src ]) return self def remove ( self , src : Node , dst : Node ) -> 'MultiMap' : \"\"\" Inplace deletes specific relationships from this map. When multiple identical relationships exists, only 1 is removed. No effect if the relationship does not exists. Args: src: Source node. Removes all mappings from a destination when it is ``MultiMap.UNDEFINED`` dst: Destination node. Removes all mappings from a source when it is ``MultiMap.UNDEFINED`` Returns: result: Modified instance of this map. \"\"\" return self . __delitem__ (( src , dst )) def clear ( self ) -> 'MultiMap' : \"\"\" Inplace deletes all relationships in this map. Returns: result: Modified instance of this map. \"\"\" self . _sources . clear () self . _targets . clear () return self def copy ( self ) -> 'MultiMap' : \"\"\" Creates a new but shallow clone of this mapping. \"\"\" return MultiMap ( self ) # visually represent state of this map. def __repr__ ( self ) -> str : return str ( list ( self )) # number & frequency of relationships match another def __eq__ ( self , other : 'MultiMap' ) -> bool : return \\ isinstance ( other , self . __class__ ) and \\ self . _sources == other . _sources and \\ self . _targets == other . _targets # union as new mapping of this & another collection def __add__ ( self , other : 'MultiMap' ) -> 'MultiMap' : return reduce ( lambda result , item : result . add ( * item ), other , MultiMap ( self ) ) # difference as new mapping of this & other collection def __sub__ ( self , other : 'MultiMap' ) -> 'MultiMap' : return reduce ( lambda result , item : result . remove ( * item ), other , MultiMap ( self ) ) # identify if specific source to destination mapping exists. def __contains__ ( self , item : Relation ) -> bool : src , dst = item in_src = src in self . _sources in_dst = dst in self . _targets return \\ in_src if src != MultiMap . UNDEFINED and dst == MultiMap . UNDEFINED else \\ in_dst if src == MultiMap . UNDEFINED and dst != MultiMap . UNDEFINED else \\ in_src and in_dst # remove explicit relation or groups or relations. def __delitem__ ( self , item : Relation ) -> 'MultiMap' : src , dst = item if src != MultiMap . UNDEFINED and dst != MultiMap . UNDEFINED : self . _decrement_frequency ( self . _sources , src , dst ) self . _decrement_frequency ( self . _targets , dst , src ) return self if src != MultiMap . UNDEFINED : for dst in self . _sources [ src ] . keys (): self . _decrement_frequency ( self . _targets , dst , src ) del self . _sources [ src ] return self if dst != MultiMap . UNDEFINED : for src in self . _targets [ dst ] . keys (): self . _decrement_frequency ( self . _sources , src , dst ) del self . _targets [ dst ] return self return self . clear () __len__ = size # cardinality __iter__ = items # iterable like list __getitem__ = source # syntactic sugar idexable like list __call__ = source # syntactic sugar callable like function # ensure source/target keys are removed when no longer linked. # returns true if freq dictionary was modified. @staticmethod def _decrement_frequency ( freq : dict , k , v ) -> bool : if k not in freq : return False freq [ k ] -= Counter ([ v ]) if freq [ k ] == Counter (): del freq [ k ] return True","title":"MultiMap"},{"location":"api_multimap.html#pyutils.multimap.MultiMap.UNDEFINED","text":"Readonly unique symbol denoting \"no-value\" of node so that None values can be handled in mapping.","title":"UNDEFINED"},{"location":"api_multimap.html#pyutils.multimap.MultiMap.domain","text":"Retrieves the current set of distinct source nodes of this map.","title":"domain"},{"location":"api_multimap.html#pyutils.multimap.MultiMap.range","text":"Retrieves the current set of distinct target nodes of this map.","title":"range"},{"location":"api_multimap.html#pyutils.multimap.MultiMap.__init__","text":"Constructor to instantiate an new MultiMap . Parameters: items ( Iterable [ Relation ] , default: None ) \u2013 Optional collection of source & destination nodes to map. Source code in pyutils/multimap.py 33 34 35 36 37 38 39 40 41 42 43 44 45 def __init__ ( self , items : Iterable [ Relation ] = None ): \"\"\" Constructor to instantiate an new ``MultiMap``. Args: items: Optional collection of source & destination nodes to map. \"\"\" self . _sources = dict () # outgoing frequencies self . _targets = dict () # incoming frequencies self . _items = None # state of iteration for src , dst in items or []: self . add ( src , dst ) return","title":"__init__()"},{"location":"api_multimap.html#pyutils.multimap.MultiMap.add","text":"Inplace inserts a specific relationship to this map even if an identical one already exists. Parameters: src ( Node ) \u2013 Source node dst ( Node ) \u2013 Destination node Returns: result ( MultiMap ) \u2013 Modified instance of this map. Source code in pyutils/multimap.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def add ( self , src : Node , dst : Node ) -> 'MultiMap' : \"\"\" Inplace inserts a specific relationship to this map even if an identical one already exists. Args: src: Source node dst: Destination node Returns: result: Modified instance of this map. \"\"\" if src != MultiMap . UNDEFINED and dst != MultiMap . UNDEFINED : self . _sources . setdefault ( src , Counter ()) . update ([ dst ]) self . _targets . setdefault ( dst , Counter ()) . update ([ src ]) return self","title":"add()"},{"location":"api_multimap.html#pyutils.multimap.MultiMap.clear","text":"Inplace deletes all relationships in this map. Returns: result ( MultiMap ) \u2013 Modified instance of this map. Source code in pyutils/multimap.py 160 161 162 163 164 165 166 167 168 169 def clear ( self ) -> 'MultiMap' : \"\"\" Inplace deletes all relationships in this map. Returns: result: Modified instance of this map. \"\"\" self . _sources . clear () self . _targets . clear () return self","title":"clear()"},{"location":"api_multimap.html#pyutils.multimap.MultiMap.copy","text":"Creates a new but shallow clone of this mapping. Source code in pyutils/multimap.py 171 172 173 174 175 def copy ( self ) -> 'MultiMap' : \"\"\" Creates a new but shallow clone of this mapping. \"\"\" return MultiMap ( self )","title":"copy()"},{"location":"api_multimap.html#pyutils.multimap.MultiMap.inverse","text":"Reverses source & destination direction mapping of all relationships in this map. Parameters: copy ( bool , default: True ) \u2013 To perform operation in new map or in place. Returns: result ( MultiMap ) \u2013 A mapping with source & destination nodes reversed. Same instance whenever copy=False Source code in pyutils/multimap.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def inverse ( self , copy : bool = True ) -> 'MultiMap' : \"\"\" Reverses source & destination direction mapping of all relationships in this map. Args: copy: To perform operation in new map or in place. Returns: result: A mapping with source & destination nodes reversed. Same instance whenever ``copy=False`` \"\"\" if copy : return MultiMap ( ( dst , src ) for src , dst in self ) self . _sources , self . _targets = self . _targets , self . _sources return self","title":"inverse()"},{"location":"api_multimap.html#pyutils.multimap.MultiMap.items","text":"Retrieves the current collection of source & destination relations in this map. Source code in pyutils/multimap.py 69 70 71 72 73 74 75 76 77 78 def items ( self ) -> Iterable [ Relation ]: \"\"\" Retrieves the current collection of source & destination relations in this map. \"\"\" return ( ( src , dst ) for src , ctr in self . _sources . items () for dst , freq in ctr . items () for _ in range ( freq ) )","title":"items()"},{"location":"api_multimap.html#pyutils.multimap.MultiMap.remove","text":"Inplace deletes specific relationships from this map. When multiple identical relationships exists, only 1 is removed. No effect if the relationship does not exists. Parameters: src ( Node ) \u2013 Source node. Removes all mappings from a destination when it is MultiMap.UNDEFINED dst ( Node ) \u2013 Destination node. Removes all mappings from a source when it is MultiMap.UNDEFINED Returns: result ( MultiMap ) \u2013 Modified instance of this map. Source code in pyutils/multimap.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def remove ( self , src : Node , dst : Node ) -> 'MultiMap' : \"\"\" Inplace deletes specific relationships from this map. When multiple identical relationships exists, only 1 is removed. No effect if the relationship does not exists. Args: src: Source node. Removes all mappings from a destination when it is ``MultiMap.UNDEFINED`` dst: Destination node. Removes all mappings from a source when it is ``MultiMap.UNDEFINED`` Returns: result: Modified instance of this map. \"\"\" return self . __delitem__ (( src , dst ))","title":"remove()"},{"location":"api_multimap.html#pyutils.multimap.MultiMap.size","text":"Number of relationships in this map. Source code in pyutils/multimap.py 102 103 104 105 106 def size ( self ) -> int : \"\"\" Number of relationships in this map. \"\"\" return sum ( 1 for _ in self ) # unfolded out","title":"size()"},{"location":"api_multimap.html#pyutils.multimap.MultiMap.source","text":"Forward maps from a specific source node & returns its collection of related target nodes if any or empty otherwise. Source code in pyutils/multimap.py 80 81 82 83 84 85 86 87 88 89 def source ( self , src : Node ) -> List [ Node ]: \"\"\" Forward maps from a specific source node & returns its collection of related target nodes if any or empty otherwise. \"\"\" return [ dst for dst , freq in self . _sources . get ( src , dict ()) . items () for _ in range ( freq ) ]","title":"source()"},{"location":"api_multimap.html#pyutils.multimap.MultiMap.target","text":"Backwards maps from a specific target node & returns its collection of related source nodes if any or empty otherwise. Source code in pyutils/multimap.py 91 92 93 94 95 96 97 98 99 100 def target ( self , dst : Node ) -> List [ Node ]: \"\"\" Backwards maps from a specific target node & returns its collection of related source nodes if any or empty otherwise. \"\"\" return [ src for src , freq in self . _targets . get ( dst , dict ()) . items () for _ in range ( freq ) ]","title":"target()"},{"location":"examples.html","text":"Examples MultiMaps Think of them like reversible dictionaries from pyutils.multimap import MultiMap # language word to definition dictionary = MultiMap([ (\"automobile\", \"wheeled road vehicle\"), (\"bank\", \"slope side of a river\"), (\"bank\", \"a financial institution\"), (\"car\", \"wheeled road vehicle\"), ]) # lookup definitions dictionary(\"bank\") # homonyms dictionary.inverse()(\"wheeled road vehicle\") # synonyms # update dictionary if \"thing\" not in dictionary.domain: dictionary += MultiMap([ (\"thing\", \"object without name\"), ])","title":"Examples"},{"location":"examples.html#examples","text":"","title":"Examples"},{"location":"examples.html#multimaps","text":"Think of them like reversible dictionaries from pyutils.multimap import MultiMap # language word to definition dictionary = MultiMap([ (\"automobile\", \"wheeled road vehicle\"), (\"bank\", \"slope side of a river\"), (\"bank\", \"a financial institution\"), (\"car\", \"wheeled road vehicle\"), ]) # lookup definitions dictionary(\"bank\") # homonyms dictionary.inverse()(\"wheeled road vehicle\") # synonyms # update dictionary if \"thing\" not in dictionary.domain: dictionary += MultiMap([ (\"thing\", \"object without name\"), ])","title":"MultiMaps"}]}